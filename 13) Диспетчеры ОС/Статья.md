Планирование выполнения задач — одна из ключевых концепций в [многозадачности](Многозадачность) и многопроцессорности как в [[ОС]] общего назначения, так и в [[ОС]] реального времени. Планирование заключается в назначении приоритетов [[процесс]]ам [[стек]] с приоритетами. Программный код, выполняющий эту задачу, называется [планировщиком](Планировщик).

Самой важной целью планирования задач является наиболее полная загрузка процессора.

В средах вычислений реального времени, например, на мобильных устройствах, предназначенных для автоматического управления в промышленности [[планировщик задач]] должен обеспечить отработку [[процесс]]ов в течение заданных временны́х промежутков (время отклика); это критично для поддержания корректной работы системы реального времени.

Для того чтобы управление [[процесс]]ами было возможным, каждому [[процесс]]у присваивается индивидуальный номер — идентификатор [[процесс]]а. Вся информация, характеризующая [[процесс]], помещается в специально отведенной области памяти, называемой блоком управления [[процесс]]ом ([[PCB]]).

Для каждого [[процесс]]а формируется свой [[PCB]] (этим занимается [[ОС]]), все [[PCB]] размещаются в памяти в виде таблицы.

![[Pasted image 20220603004751.png]]

Таким образом, зная местоположение таблицы [[PCB]] (адрес первого блока), [[ОС]] может получить доступ к информации о любом процессе. Каждый процесс определяется своим блоком [[PCB]].

[[Диспетчер процессов]] представляет собой программу (процесс), входящую в состав [[ОС]]. В распоряжении диспетчера имеется информация обо всех процессах, существующих в системе в данный момент

![[Pasted image 20220603004844.png]]

Список [[процесс]]ов, находящихся в состоянии готовности, содержит перечень идентификаторов [[процесс]]ов, ожидающих выполнения на процессоре и имеющих в своем распоряжении все необходимые [[ресурс]]ы для этого.

Список заблокированных [[процесс]]ов содержит идентификаторы [[процесс]]ов, ожидающих выделения им какого-либо [[ресурс]]а.

Список событий содержит информацию о событиях, которые связаны с занятием или освобождением [[ресурс]]ов в системе. Наступление таких событий может повлиять на переход процесса из состояния блокировки в состояние готовности. Примером такого события может служить получение сигнала готовности от ведомого устройства в случае асинхронного обмена.

Диспетчер активизируется таймером через заданные промежутки времени ![[Pasted image 20220603004943.png]]

При каждой активизации [[диспетчер процессов]] выполняет следующие действия:

Перевод процессов из состояния блокировки в состояние готовности. Диспетчер анализирует список событий и определяет, какой из процессов можно перевести из состояния блокировки в состояние готовности в соответствии с каждым событием. Каждое событие связано с освобождением или занятием некоторого [[ресурс]]а и при его наступлении [[процесс]], ожидающий предоставления этого [[ресурс]]а, может быть переведен в состояние готовности, если необходимый ему [[ресурс]] освободился. Если несколько процессов находятся в ожидании одного и того же [[ресурс]]а, применяется схема приоритетов, позволяющая выбрать из конкурирующих [[процесс]]ов [[процесс]] с наивысшим приоритетом и перевести в состояние готовности именно его. Например, если один из заблокированных [[процесс]]ов ожидает сигнала готовности от ведомого устройства (случай асинхронного обмена), при обнаружении события поступления этого сигнала в списке [событий](Событие) диспетчер переводит этот [[процесс]] в состояние готовности. Перевод в состояние готовности заключается в то, что:

Изменяется состояние процесса в [[PCB]] этого процесса (с L на R).

Идентификатор этого [[процесс]]а изымается из списка заблокированных [[процесс]]ов и помещается в список [[процесс]]ов, находящихся в состоянии готовности.

Перевод [[процесс]]ов из состояния готовности в активное состояние. Для всех [[процесс]]ов, находящихся в состоянии готовности, определяется приоритет. [[процесс]] с максимальным приоритетом переводится в активное состояние (начинает выполняться на [[процесс]]оре). [[процесс]], бывший до этого активным, переводится в состояние готовности и помещается в список готовых [[процесс]]ов. Определение приоритетов [[процесс]]ов происходит в соответствии с одной из типовых схем, например наибольший приоритет получает [[процесс]], дольше всего находившийся в состоянии готовности (дольше всего не исполнявшийся) или использовавший суммарно наименьшее количество [[процесс]]орного времени. Перевод [[процесс]]а в активное состояние заключатся в следующем:

Изменяется состояние [[процесс]]а в [[PCB]] этого [[процесс]]а (с R на A).

Идентификатор этого [[процесс]]а изымается из списка [[процесс]]ов, находящихся в состоянии готовности.

Такие действия диспетчера получили названия планирования [[процесс]]ов. Так как диспетчер вызывается с интервалом  , с таким же интервалом происходит перепланирование [[процесс]]ов. Следовательно, каждому [[процесс]]у отводится интервал времени **τ** для выполнения, после чего он переводится в состояние готовности, а активным становится другой [[процесс]]. Интервал **τ** часто называют квантом [[процесс]]ора. Величина кванта [[процесс]]ора определяется аппаратными настройками вычислительной системы (таймера). Как правило, она составляет несколько десятых долей секунды.

Понятие асинхронных процессов

[[процесс]]ы относятся к асинхронным, если скорости исполнения любой части [[процесс]]а не взаимосвязаны друг с другом и с другими [[процесс]]ами. Другими словами, если есть два асинхронных [[процесс]]а, и в каждом из них мы выделим определенную группу команд, нельзя сказать заранее, какой [[процесс]] выполнит "свою" выделенную группу раньше. Такая ситуация вызвана тем, что время работы асинхронного [[процесс]]а нельзя точно определить так как он может содержать в себе задержки, время которых не поддается точной оценке. Например, если [[процесс]] выполняет обмен с асинхронным устройством, и устройство не готово, возникает задержка до готовности устройства, и длительность этой задержки заранее не известна.

Задача синхронизации асинхронных [[процесс]]ов возникает в следующих случаях:

· Если [[процесс]]ы обращаются к одному [[ресурс]]у, который является неразделяемым и может быть использован только одним [[процесс]]ом в данный момент времени. В этом случае, после начала обращения к [[ресурс]]у одним [[процесс]]ом, необходимо не допустить обращения к этому [[ресурс]]у со стороны других [[процесс]]ов.

· Задача организации строгой последовательности обращения [[процесс]]ов к общему [[ресурс]]у. Например, два [[процесс]]а используют общую область памяти для обмена данными, причем один [[процесс]] выполняет запись данных в эту область, а второй — чтение. В этом случае задача недопущения одновременного обращения [[процесс]]ов к [[ресурс]]у дополняется задачей организации строгой последовательности доступа к нему: сначала обращается "пишущий" [[процесс]], потом "читающий" и т.д.

Решение задачи синхронизации

Задача синхронизации предусматривает, что если один асинхронный [[процесс]] начал выполнение некоей группы команд (работа с [[ресурс]]ом), другой асинхронный [[процесс]] не должен начинать выполнение своей группы команд, работающих с этим же [[ресурс]]ом. Такая группа команд, выполнение которой должно быть синхронизировано с другими [[процесс]]ами, называется критическим участком (критическим блоком).

Если [[процесс]] 1 начал выполнение своего критического участка (КУ), [[процесс]] 2 не должен начинать выполнение своего КУ до завершения первым [[процесс]]ом выполнения КУ. Такая ситуация получила название задачи взаимоисключения.

Самый простой путь решения задачи взаимоисключения — после начала выполнения [[процесс]]ом КУ запретить активизацию другого, конкурирующего [[процесс]]а. То есть запретить передиспетчеризацию [[процесс]]ов, например, запретив прерывания в системе. Кстати говоря, нечто подобное уже рассматривалось нами при знакомстве с организацией прерываний — программа имела возможность запретить обработку прерываний на время выполнения некоего участка кода, выполнение которого не может быть прервано.

Однако этот путь имеет большой недостаток. Дело в том, что время, необходимое для выполнения КУ [[процесс]]ом неизвестно. Вообще говоря, оно может быть достаточно большим. И если на это время запретить диспетчеризацию в системе, все остальные [[процесс]]ы (включая саму ОС) будут блокированы на неопределенное время. Такой подход не может быть признан корректным.